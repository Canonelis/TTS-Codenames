--[[
  TTS-Codenames: A LUA script for Codenames on Tabletop Simulator for Steam.
  Copyright (C) 2021  Ryan6578 (https://ryan6578.com)

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program. If not, see <http://www.gnu.org/licenses/>.
]]

chatDisclaimer =
[[

                  [da1918]ANALYTICS DISCLAIMER[-]
[-]This mod collects certain data to improve the
experience and provide meaningful insight
into usage and play. By continuing, you
acknowledge and accept this in accordance
with the privacy policy outlined below.

More info:
[8bb5ff]https://tts-codenames.com/privacy[-]

]]

redColor  = {0.856, 0.1, 0.094}
blueColor = {0.118, 0.53, 1}
dealCards_WaitId = nil

-- Color = Blue/Red/Black/White
cards = {
  -- Row 1 (cards 1-5)
  {position = {x = -11.4, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 12.6}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 2 (cards 6-10)
  {position = {x = -11.4, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 8.75}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 3 (cards 11-15)
  {position = {x = -11.4, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z =  4.9}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 4 (cards 16-20)
  {position = {x = -11.4, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = 1.05}, guid = nil, id = nil, value = nil, color = nil, covered = false},

  -- Row 5 (cards 21-25)
  {position = {x = -11.4, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  -5.7, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =     0, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =   5.7, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false},
  {position = {x =  11.4, z = -2.8}, guid = nil, id = nil, value = nil, color = nil, covered = false}
}

agents = {
  -- Assassain
  ['b97df2'] = {position = {x = 0.04, y = 2, z = -17.84 }, color = "Black", covering = nil, enabled = true},

  -- Blue agents
  ['1e9282'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Blue", covering = nil, enabled = false},
  ['7fdaee'] = {position = {x = 12.34, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['99832c'] = {position = {x = 18.07, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['d9324a'] = {position = {x = 23.77, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['19b2d5'] = {position = {x = 29.47, y = 2, z = -13.97 }, color = "Blue", covering = nil, enabled = true},
  ['0f0ec0'] = {position = {x = 12.34, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['d9054c'] = {position = {x = 18.07, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['4de840'] = {position = {x = 23.77, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},
  ['05c73d'] = {position = {x = 29.47, y = 2, z = -17.8  }, color = "Blue", covering = nil, enabled = true},

  -- Red agents
  ['3ef1ca'] = {position = {x = 0.04, y = 2, z = -14 }, color = "Red", covering = nil, enabled = false},
  ['746660'] = {position = {x = -12.22, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['9cbe84'] = {position = {x = -17.92, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['6bb4d8'] = {position = {x = -23.62, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['b48ed4'] = {position = {x = -29.32, y = 2, z = -13.97 }, color = "Red", covering = nil, enabled = true},
  ['5c1be6'] = {position = {x = -12.22, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['b89ba7'] = {position = {x = -17.92, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['e1754e'] = {position = {x = -23.62, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},
  ['4a2969'] = {position = {x = -29.32, y = 2, z = -17.8  }, color = "Red", covering = nil, enabled = true},

  -- Civialians
  ['1f53f2'] = {position = {x = -5.7, y = 2, z = -14 }, color = "White", covering = nil, enabled = true},
  ['3d7b86'] = {position = {x = 5.74, y = 2, z = -14 }, color = "White", covering = nil, enabled = true},
  ['e44594'] = {position = {x = -5.7, y = 2, z = -17.84 }, color = "White", covering = nil, enabled = true},
  ['1ebedd'] = {position = {x = 5.74, y = 2, z = -17.84 }, color = "White", covering = nil, enabled = true},
  ['f6786b'] = {position = {x = -5.7, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true},
  ['f8f6a1'] = {position = {x = 0.04, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true},
  ['a05e4e'] = {position = {x = 5.74, y = 2, z = -21.7 }, color = "White", covering = nil, enabled = true}
}

votes = {
  [0] = {
    ["Orange"]  = {},
    ["Yellow"]  = {},
    ["Pink"]    = {},
    ["Brown"]   = {}
  },
  [1] = {
    ["Teal"]    = {},
    ["Purple"]  = {},
    ["Green"]   = {},
    ["White"]   = {}
  }
}

----------[ Game state ]----------
gameState =
{
  -- Tracks whether the current game has started (-2 = not started, -1 = ended, 0 = starting, 1 = started)
  status = -2,

  -- Current game is on the first turn or not
  firstTurn = true,

  -- Tracks whose turn it currently is
  turnTracker = 1,

  -- Tracks how many guesses the team has left
  guessesLeft = -1,

  -- Tracks if the current team is able to vote
  canVote = false,

  -- Red clue tracker
  redClues = {},

  -- Blue clue tracker
  blueClues = {}
}

----------[ Game settings ]----------
settings =
{
  -- Shuffle players at start
  playerShuffle = true,

  -- Enable codemaster queue
  codemasterQueue = true,

  -- Quick color switcher buttons
  colorSwitcher = true,

  -- Disable/Enable "inf meta"
  cardTilting = false,

  -- Allow multiple votes per player
  multivoting = false,

  -- Show shooting star background
  starBackground = true,

  -- Show table lighting
  tableLighting = true,

  -- AFK detection
  afkDetection =
  {
    enabled   = false,
    threshold = 7
  },

  -- Timer enabled
  timer =
  {
    enabled     = true,
    initial     = 8,
    subsequent  = 4
  },

  -- Automod functions
  automod =
  {
    autokick = true
  }
}

----------[ Decks ]----------
deck =
{
  -- The currently selected deck(s)
  selected = {},

  -- Whether or not multiple deck mode is enabled
  multiple = false,

  -- The current words for the selected deck
  words = nil,

  -- Search term
  searchTerm = nil,

  -- Number of decks matched by the searchTerm
  matchingDecks = 0,

  -- Wait id of search delay
  searchDelay = nil,

  -- Current page size
  pageSize = 10,

  -- Current result page
  pageNum = 1,

  -- Used to save the current deck data
  currentDeckList = {}
}

----------[ Game analytics ]----------
analytics =
{
  url       = "https://api.tts-codenames.com",
  gameID    = nil,
  host      = nil,
  clueID    = nil,
  sessions  = {}
}

----------[ Variables to manage the complex deck requests ]-----------
function resetDeckHandler()
  deckHandler =
  {
    -- Tracks deck fetch request
    fetchingDecks = false,

    -- Total number of decks expected
    totalDecks = 0,

    -- Number of pages to request
    totalPages = 0,

    -- Number of decks to request at a time. JSON.decode is a very slow function.
    DECK_REQUEST_COUNT = 15,

    -- A table to track which page numbers have come in so far
    acquiredPages = {},

    -- The list of all decks
    entireDeckList = {}
  }
end
resetDeckHandler()

------ Track players who come in the room ----
-- If they sit in red or blue, then reload the global xml in case they can't see it
isPlayerNewlyJoined = {}

----------[ Character sets ]----------

digits_table = {
[0]={48,1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296},
[1]={49,1633,1777,1985,2407,2535,2663,2791,2919,3047,3175,3303,3431,3559,3665,3793,3873,4161,4241,6113,6161,6471,6609,6785,6801,6993,7089,7233,7249,42529,43217,43265,43473,43505,43601,44017,65297},
[2]={50,1634,1778,1986,2408,2536,2664,2792,2920,3048,3176,3304,3432,3560,3666,3794,3874,4162,4242,6114,6162,6472,6610,6786,6802,6994,7090,7234,7250,42530,43218,43266,43474,43506,43602,44018,65298},
[3]={51,1635,1779,1987,2409,2537,2665,2793,2921,3049,3177,3305,3433,3561,3667,3795,3875,4163,4243,6115,6163,6473,6611,6787,6803,6995,7091,7235,7251,42531,43219,43267,43475,43507,43603,44019,65299},
[4]={52,1636,1780,1988,2410,2538,2666,2794,2922,3050,3178,3306,3434,3562,3668,3796,3876,4164,4244,6116,6164,6474,6612,6788,6804,6996,7092,7236,7252,42532,43220,43268,43476,43508,43604,44020,65300},
[5]={53,1637,1781,1989,2411,2539,2667,2795,2923,3051,3179,3307,3435,3563,3669,3797,3877,4165,4245,6117,6165,6475,6613,6789,6805,6997,7093,7237,7253,42533,43221,43269,43477,43509,43605,44021,65301},
[6]={54,1638,1782,1990,2412,2540,2668,2796,2924,3052,3180,3308,3436,3564,3670,3798,3878,4166,4246,6118,6166,6476,6614,6790,6806,6998,7094,7238,7254,42534,43222,43270,43478,43510,43606,44022,65302},
[7]={55,1639,1783,1991,2413,2541,2669,2797,2925,3053,3181,3309,3437,3565,3671,3799,3879,4167,4247,6119,6167,6477,6615,6791,6807,6999,7095,7239,7255,42535,43223,43271,43479,43511,43607,44023,65303},
[8]={56,1640,1784,1992,2414,2542,2670,2798,2926,3054,3182,3310,3438,3566,3672,3800,3880,4168,4248,6120,6168,6478,6616,6792,6808,7000,7096,7240,7256,42536,43224,43272,43480,43512,43608,44024,65304},
[9]={57,1641,1785,1993,2415,2543,2671,2799,2927,3055,3183,3311,3439,3567,3673,3801,3881,4169,4249,6121,6169,6479,6617,6793,6809,7001,7097,7241,7257,42537,43225,43273,43481,43513,43609,44025,65305}
}

spaceCharacters = {}
for _, code in pairs({32,160,5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8239,8287,12288,65279}) do
  spaceCharacters[code] = true
end

hyphenCharacters = {}
for _, code in pairs({45,8208,8209,8210,8211,8212,8213,11834,11835,65112,65123,65293}) do
  hyphenCharacters[code] = true
end

digitCharacters = {}
for digit, arr in pairs(digits_table) do
  for _, code in pairs(arr) do
    digitCharacters[code] = tostring(digit) -- strings are interpreted as 'true' for boolean expressions, even empty ones
  end
end

whitespaceCharacters = {}
for _, code in pairs({9,10,11,12,13,28,29,30,31,133,8232,8233}) do
  whitespaceCharacters[code] = true
end
for code, _ in pairs(spaceCharacters) do
  whitespaceCharacters[code] = true
end

illegalCharacters   = {}
-- put several character ranges into the illegalCharacters table
local illegalCharacterRanges =
          {
            {0, 64},    -- before uppercase letters
            {91, 96},   -- before lowercase letters
            {123, 191}, -- before accented letters
            {215, 215}, {247, 247}, -- multiplication and division sign
            {448, 451}, -- symbols
            {688, 767}, -- symbols
          }
for _, range in pairs(illegalCharacterRanges) do
  local code_st, code_end = table.unpack(range)
  for code = code_st, code_end do
    illegalCharacters[code] = true
  end
end
-- include hyphens
for code, _ in pairs(hyphenCharacters) do
  illegalCharacters[code] = true
end
-- include whitespace characters
for code, _ in pairs(whitespaceCharacters) do
  illegalCharacters[code] = true
end
-- include digit characters
for code, _ in pairs(digitCharacters) do
  illegalCharacters[code] = true
end

function findInArray(val,arr,cmp_func) --cmp_func is optional, a function with two arguments that returns a boolean value
  -- returns the index of the value in the table
  if type(arr) ~= "table" then
    return nil
  end
  if cmp_func ~= nil then
    if type(cmp_func) == "function" then
      for i, v in pairs(arr) do
        success, res = pcall(cmp_func,v,val)
        if success then
          if res == true then
            return i
          end
        else
          error("findInArray:custom compare function failed with error:"..tostring(res))
        end
      end
    else
      error("findInArray:custom compare function is not a function or does not have 2 arguments.")
    end
  else
    for i, v in pairs(arr) do
      if v == val then
        return i
      end
    end
  end
  return nil
end

function printTable(t,return_as_string,table_id_list)
	local s
	return_as_string = return_as_string == true -- default is false
	if table_id_list == nil then -- used if table has been seen before. don't display it again
		table_id_list = {}
	end
	if type(t) == "nil" or type(t) == "boolean" then
		s = string.upper(tostring(t))
	elseif type(t) == "number" or type(t) == "function" then
		s = tostring(t)
	elseif type(t) == "table" and table_id_list[t] == nil then
    table_id_list[t] = true
    local strings_list = {}
    for i, v in pairs(t) do
      table.insert(strings_list,tostring(i)..":"..printTable(v,true,table_id_list))
    end
    s = "{"..table.concat(strings_list,",").."}"
	else
		s = '"'..tostring(t)..'"'
	end
	if return_as_string then
		return s
	else
		return print(""..string.gsub(s,"%[([0-9A-Fa-f][0-9A-Fa-f]+)%]","[#%1]"))
	end
end

----------[ AFK loop checking ]----------
afk =
{
  -- Wait id of the afk loop
  waitId = nil,

  -- To detect a VR player, getPointerRotation() never ever changes(except with "lookAt"). If a player's rotation changes several times the we know they are not in VR.
  personInfo =
  { -- [steamId]:
    -- isNonVrPlayer = false,
    -- currentPointerRotation = 0,
    -- cprChanged = false,
    -- uniquePointerRotations = {},
    -- uniquePointerRotationsCount = 0
  },

  -- The number of uniquePointerRotationsCount needed to assert non-VR status
  nonVrThreshold = 6,

  -- For non-VR users, track their cursor position
  colorInfo =
  { -- [color]:
    -- steamId = nil,
    -- timestamp = nil,
    -- cursorPosition = nil,
    -- countdown = nil
  }
}
function onload(saveState)

  -- Codenames script version
  version = "3.2.3"

  ----------[ Script object initialization ]----------
  -- Control panels and table objects
  customTable     = getObjectFromGUID("bab013")
  tableObject     = getObjectFromGUID("0a61c6")

  -- Game objects
  cardTemplates   = getObjectFromGUID("2fb333")
  extraBlue       = getObjectFromGUID("1e9282")
  extraRed        = getObjectFromGUID("3ef1ca")
  redToken        = getObjectFromGUID("f3cdf2")
  blueToken       = getObjectFromGUID("3f75b3")
  buttonRed       = getObjectFromGUID("f16a9a")
  buttonBlue      = getObjectFromGUID("c91f34")

  ----------[ Interactable objects ]----------
  -- Control panels and table objects
  customTable.interactable    = false
  tableObject.interactable    = false

  -- Game objects
  cardTemplates.interactable  = false
  extraBlue.interactable      = false
  extraRed.interactable       = false
  redToken.interactable       = false
  blueToken.interactable      = false

  -- Create variable for storing typed clues
  currentEnteredClue = {}

  -- Get the list of decks
  api_getDecks()

  buttonBlue.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  buttonRed.createButton({
  label="[END TURN]", click_function="endTurn", function_owner=self,
    position={0,-0.15,0}, rotation={0,90,0}, height=1000, width=2000, font_size=10
  })

  -- Make agents non-selectable
  for agentGUID, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(agentGUID)
    if agentObject then
      agentObject.drag_selectable = false
    end
  end

  -- Change seated players views
  seatedPlayers = Player.getPlayers()
  for _, player in ipairs(seatedPlayers) do
    player.print(chatDisclaimer, {1, 1, 1})
    Wait.frames(function()
      player.lookAt({
        position = {0, 0, 0},
        pitch    = 60,
        yaw      = 0,
        distance = 45
      })
    end, 1)
  end

  -- Load save state - if one exists
  if saveState != "" then
    local decodedSaveState = JSON.decode(saveState)

    -- TODO:
      -- currently selected decks
      -- table ui elements

    if decodedSaveState.version == version and decodedSaveState.gameState.status != -2 then
      -- Return players to their original seats if loading a very recent save
      if decodedSaveState.gameState.status == 1 and os.time() - decodedSaveState.time < 60 then
        tableObject.call("assignSeats",decodedSaveState.seating)
      end
      -- Load the previous gameState
      gameState = decodedSaveState.gameState

      -- Load the previous settings and update the view
      settings = decodedSaveState.settings
      tableObject.call("updateSettings")

      -- Load the analytics data
      analytics = decodedSaveState.analytics

      -- Load the card data and update their UI
      cards = decodedSaveState.cards
      dealCards()

      -- Update the enabled property for agents
      agents = decodedSaveState.agents

      -- Make the correct extra agent interactable
      extraBlue.interactable = agents[extraBlue.guid].enabled
      extraRed.interactable = agents[extraRed.guid].enabled

      for agentGUID, agentData in pairs(agents) do
        if agentData.covering ~= nil then
          coverCard(agentData.covering, agentGUID)
        elseif agentData.enabled and getObjectFromGUID(agentGUID) then
          -- use onObjectDrop to reset its position if it is out of place
          onObjectDrop("Black", getObjectFromGUID(agentGUID))
        end
      end
    end
  end

  for _, player in ipairs(Player.getPlayers()) do
    if player.host then
      analytics.host = player.steam_id
      break
    end
  end

  -- Start the AFK loop checker
  if settings.afkDetection.enabled then
    settings.afkDetection.waitId = Wait.time(afkCheckLoop, 1, -1)
  end

  -- If there are many custom assets in the save, sometimes the global xml UI won't load
  -- reset it for everyone in the room
  Wait.time(function()
         UI.setXml(globalXmlText)
        end,
        5, 1)
end

function onSave()
  local saveData = {}

  saveData.version    = version
  saveData.gameState  = gameState
  saveData.settings   = settings
  saveData.analytics  = analytics
  saveData.cards      = cards
  saveData.agents     = agents

  saveData.time       = os.time()
  saveData.seating    = {}
  for _, p in pairs(Player.getPlayers()) do
    if p.color != "Grey" then
      saveData.seating[p.steam_id] = p.color
    end
  end

  return JSON.encode(saveData)
end

------------------------------------------------------------------------
--------------------[ SETTERS/GETTERS FOR SETTINGS ]--------------------
------------------------------------------------------------------------

function setShuffle(enabled) settings.playerShuffle = enabled end
function getShuffle() return settings.playerShuffle end

function setQueue(enabled) settings.codemasterQueue = enabled end
function getQueue() return settings.codemasterQueue end

function setSwitcher(enabled) settings.colorSwitcher = enabled end
function getSwitcher() return settings.colorSwitcher end

function setTilting(enabled) settings.cardTilting = enabled end
function getTilting() return settings.cardTilting end

function setMultivoting(enabled) settings.multivoting = enabled end
function getMultivoting() return settings.multivoting end

function setAfk(enabled)
  settings.afkDetection.enabled = enabled
  if settings.afkDetection.waitId != nil then
    Wait.stop(settings.afkDetection.waitId)
    settings.afkDetection.waitId = nil
  end
  if settings.afkDetection.enabled then
    afk.colorInfo = {}
    settings.afkDetection.waitId = Wait.time(afkCheckLoop, 1, -1)
  end
end

function setTimer(enabled)
  settings.timer.enabled = enabled
  if settings.timer.enabled then
    if gameState.status == 1 then
      startTime()
    else
      tableObject.call("stopTimer", true)
    end
  else
    -- Disable the timer
  end
end
function getAfk() return settings.afkDetection.enabled end

function setAfkTime(value)
  afk.colorInfo = {}
  settings.afkDetection.threshold = value
end
function getAfkTime() return settings.afkDetection.threshold end

function getTimer() return settings.timer.enabled end

function setTimer1Time(value) settings.timer.initial = value end
function getTimer1Time() return settings.timer.initial end

function setTimer2Time(value) settings.timer.subsequent = value end
function getTimer2Time() return settings.timer.subsequent end

function setAutokick(enabled) settings.automod.autokick = enabled end
function getAutokick() return settings.automod.autokick end

function toggleDeckMode() deck.multiple = not deck.multiple end
function getMultipleDeckMode() return deck.multiple end

function afkCheckLoop()
  if settings.afkDetection.enabled then
    for _, player in pairs(Player.getPlayers()) do
      if afk.personInfo[player.steam_id] and afk.personInfo[player.steam_id].isNonVrPlayer then
        -- If the player was eventually detected as a non-VR player then check if their cursor position has moved
        local movementInfo = afk.movementInfo[player.steam_id]
        if movementInfo == nil then
          -- They are new so set their data and skip them
          afk.movementInfo[player.steam_id] = {
            color = player.color,
            timestamp = Time.time,
            cursorPosition = player.getPointerPosition() or Vector(0, 0, 0),
            countdown = nil
           }
          break
        end

        if player.color ~= "Grey" and player.color ~= "Black" and player.color ~= "Red" and player.color ~= "Blue" and not player.blindfolded then
          -- Only if the player is seated as a guesser
          local colorInfo = afk.colorInfo[player.color]
          if colorInfo == nil or colorInfo.steamId != player.steam_id then
            -- This is a new player so reset data and skip them
            afk.colorInfo[player.color] = {
              steamId = player.steam_id,
              timestamp = Time.time,
              cursorPosition = player.getPointerPosition(),
              countdown = nil
             }
            break
          end
          local pos = player.getPointerPosition()
          if pos != nil then
            local max_delta = 0
            for _, coord in pairs({'x','y','z'}) do
              max_delta = math.max(max_delta,math.abs(movementInfo.cursorPosition[coord] - pos[coord]))
            end
            if max_delta > 0.01 then
              -- Cursor position isn't the same. log the new position
              movementInfo.timestamp = Time.time
              movementInfo.cursorPosition = pos
              movementInfo.countdown = nil
            else
              if Time.time - movementInfo.timestamp > settings.afkDetection.threshold * 60 - 5 then
                -- Since this function isn't called exactly every second, use a pretty countdown
                if movementInfo.countdown == nil then
                  movementInfo.countdown = 5
                end
                if movementInfo.countdown < 0 then
                  -- Switch player to spectator
                  player.broadcast("You have been moved to spectator for AFKing more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).", redColor)
                  printToAll("Player " .. tostring(player.steam_name) .. " has been moved to spectator for being AFK for more than " .. tostring(settings.afkDetection.threshold) .. " minute(s).",  stringColorToRGB(player.color))
                  player.changeColor("Grey")
                else
                  player.broadcast("You will be removed due to AFK in: " .. movementInfo.countdown, redColor)
                end
                movementInfo.countdown = movementInfo.countdown - 1
              else
                movementInfo.countdown = nil
              end
            end
          end
        else
          -- If the player is immune to greying, then update their info
          movementInfo.timestamp = Time.time
          movementInfo.cursorPosition = Vector(0, 0, 0)
          movementInfo.countdown = nil
        end
      else
        -- Add pointer rotation to the list for the player
        local personInfo = afk.personInfo[player.steam_id]
        if personInfo == nil then
          -- Person never seen before so create their profile and skip them
          afk.personInfo[player.steam_id] = {
            isNonVrPlayer = false,
            currentPointerRotation = player.getPointerRotation(),
            cprChanged = false,
            uniquePointerRotations = {},
            uniquePointerRotationsCount = 0
          }
          break
        end

        local rot = player.getPointerRotation()
        if personInfo.currentPointerRotation != rot then
          -- Wait as many cycles as it takes for any 'lookAt' commands to settle
          personInfo.cprChanged = true
        elseif personInfo.cprChanged == true then
          -- If rotation is too close to a whole number, assume it was done by the "lookAt" command and ignore the change
          if rot % 1 > 0.0001 and rot % 1 < 0.9999 then
            if not personInfo.uniquePointerRotations[rot] then
              -- We found a unique pointer rotation. add it to their list
              personInfo.uniquePointerRotations[rot] = true
              personInfo.uniquePointerRotationsCount = personInfo.uniquePointerRotationsCount + 1
              if personInfo.uniquePointerRotationsCount >= afk.nonVrThreshold then
                -- This is a non-VR person so set them to grey if their cursor position doesn't change
                personInfo.isNonVrPlayer = true
              end
            end
          end
          personInfo.cprChanged = false
        end
        personInfo.currentPointerRotation = rot
      end
    end
  end
end

function refreshDeckElements()
  -- Get current deck elements to show

  local deckList = {}

  -- Keep a count of decks that would make it into the pages
  local count = 0
  -- Matching decks between these counts will be included in the displayed deck list
  local count_min = (deck.pageNum - 1) * deck.pageSize + 1
  local count_max = deck.pageNum * deck.pageSize

  for i = 1, #deckHandler.entireDeckList do
    if deck.searchTerm == nil or deck.searchTerm == "" or #deck.searchTerm > 100
        or deckHandler.entireDeckList[i]["author"] and deckHandler.entireDeckList[i]["author"]["displayName"] and string.find(deckHandler.entireDeckList[i]["author"]["displayName"], deck.searchTerm, 1, true)
        or deckHandler.entireDeckList[i]["name"] and string.find(deckHandler.entireDeckList[i]["name"], deck.searchTerm, 1, true)
        or deckHandler.entireDeckList[i]["description"] and string.find(deckHandler.entireDeckList[i]["description"], deck.searchTerm, 1, true)
      then

      -- When the count of the deck is in the correct range, add it to the list of decks to display
      count = count + 1
      if count >=  count_min and count <= count_max then
        table.insert(deckList, deckHandler.entireDeckList[i])
      end
    end
  end

  -- Check if we are past the last page and redo function
  if count > 0 and #deckList == 0 then
    deck.pageNum = math.ceil(count / deck.pageSize)
    refreshDeckElements()
    return
  end

  -- Set this to be able to calculate the final page number available
  deck.matchingDecks = count

  for i = 1, 20, 1 do
    if deckList[i] then
      tableObject.UI.setAttribute("deck" .. i .. "Button", "onClick", "setDeck(" .. deckList[i]["deckID"] .. ")")
      -- Deck image
      if deckList[i]["author"]["steamID"] == nil then
        tableObject.UI.setAttribute("deck" .. i .. "Official", "active", true)
        tableObject.UI.setAttribute("deck" .. i .. "Image", "active", false)
      elseif deckList[i]["author"]["profilePicture"] then
        tableObject.UI.setAttribute("deck" .. i .. "Official", "active", false)

        tableObject.UI.setAttributes("deck" .. i .. "Image", {
          active  = true,
          image   = deckList[i]["author"]["steamID"]
        })
      end

      tableObject.UI.setAttributes("deck" .. i .. "Name", {
        text      = deckList[i]["name"]
      })
      tableObject.UI.setAttributes("deck" .. i .. "Author", {
        text    = (deckList[i]["author"]["displayName"] and ("by " .. deckList[i]["author"]["displayName"]) or "Official Deck")
      })
      tableObject.UI.setAttributes("deck" .. i .. "Description", {
        text    = deckList[i]["description"],
        active  = (deckList[i]["description"] == nil and "false" or "true")
      })

      tableObject.UI.setAttribute("deck" .. i .. "Button", "color", "#ffffff")
      for deckIndex, deckGUID in ipairs(deck.selected) do
        if deckGUID == deckList[i]["deckID"] then
          tableObject.UI.setAttribute("deck" .. i .. "Button", "color", "#aaeaa7")
          break
        end
      end

      tableObject.UI.setAttribute("deck" .. i, "active", true)
    else
      tableObject.UI.setAttribute("deck" .. i, "active", false)
    end
  end
  tableObject.UI.setValue("pageMarker", "Page: " .. deck.pageNum .. " / " .. math.ceil(deck.matchingDecks / deck.pageSize))

  -- Save the current deck list
  deck.currentDeckList = deckList
end

function previousPage()
  if (deck.pageNum <= 1) or deck.fetchingDecks then
    return
  end

  deck.pageNum = deck.pageNum - 1
  refreshDeckElements()
end

function nextPage()
  if (deck.pageNum >= math.ceil(deck.matchingDecks / deck.pageSize)) or deck.fetchingDecks then
    return
  end

  deck.pageNum = deck.pageNum + 1
  refreshDeckElements()
end

function searchDecks(searchTerm)
  deck.searchTerm = searchTerm

  if deck.searchDelay then
    Wait.stop(deck.searchDelay)
    deck.searchDelay = nil
  end

  deck.searchDelay = Wait.time(function()
    deck.pageNum = 1
    refreshDeckElements()
    deck.searchDelay = nil
  end, 0.5)
end

function clueEntered(player, value)
  -- Because of how MoonSharp handles its matching expressions,
  -- absolutely no expression matching from the string library can be used for unicode clues.
  -- It converts all characters to values 0..255 before running the expression on it.
  -- eg. %s will match all characters with codes 0x0A, 0x20, 0x10A, 0x400A, 0x7020
  -- string.lower upper find etc. work fine and properly even for other character sets

  local color = player.color
  local newLineInd = string.find(value, "\n")
  if newLineInd == nil then
    -- Save the clue for when the user presses enter
    currentEnteredClue[color] = value
  else
    -- Get the clue from before the user pressed enter
    if currentEnteredClue[color] then
      value = currentEnteredClue[color]
      currentEnteredClue[color] = nil
    else
      value = ""
    end

    -- Reset the text box
    local resetInput = {
      text          = "",
      placeholder   = "Enter clue here"
    }
    UI.setAttributes(color:lower() .. "ClueText", resetInput)

    --if the clue is empty then do nothing
    if #value == 0 then
      return
    end

    -- if the game hasn't been started, a clue cannot be entered
    if gameState.status ~= 1 then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You must start a game to enter a clue! [a020f0]«")
      return
    end

    -- Make sure that it's the current codemaster's turn
    if (color == "Blue" and gameState.turnTracker == 0) or (color == "Red" and gameState.turnTracker == 1) then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to enter a clue! [a020f0]«")
      return
    end

    -- if the clue is long, dont bother processing it
    if #value > 50 then
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. Please enter a valid clue and push ENTER! [a020f0]«")
      return
    end

    -- Parse the entered clue into its respective parts
    local clue, number, error = getClueDetails(value)

    -- Handle clue parsing errors
    if error then
      -- Clue wasn't able to be parsed - general error
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. Please enter a valid clue and push ENTER! [a020f0]«")
      return
    elseif number != "inf" and tonumber(number) > 9 then
      -- Clue was larger than 9 words (not 0 or inf)
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Clues cannot be for more than 9 words. [a020f0]«")
      return
    elseif string.len(clue) > 20 then
      -- Clue was larger than 20 characters
      Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Clues cannot be longer than 20 characters. [a020f0]«")
      return
    end

    -- Standardize clue to lowercase
    clue = clue:lower()

    -- Don't allow a clue that isn't covered
    for cardIndex, cardData in ipairs(cards) do
      if not cardData.covered and cardData.value:lower() == clue:lower() then
        Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]Invalid clue. That word has not been covered yet, so it may not be used! [a020f0]«")
        return
      end
    end

    -- Track remaining clues
    if number == "inf" then
      gameState.guessesLeft = -1
    elseif tonumber(number) == 0 then
      gameState.guessesLeft = -1
    else
      gameState.guessesLeft = tonumber(number) + 1
    end

    -- Encode the finished clue
    encodeClue(color, clue .. " - " .. number:gsub("inf", "∞"))

    -- Enable voting for the current team
    gameState.canVote = true

    -- Send analytics data for the new clue
    api_newClue(clue, (number == "inf" and -1 or number), Player[color].steam_id)
  end
end

function getClueDetails(processedClue)
  local clueState = {}
  clueState.PRE_WHITESPACE = 1
  clueState.INF_N = 2
  clueState.INF_I = 3
  clueState.NUMBER = 4
  clueState.INF_WHITESPACE = 5 -- inf must have 1 space before clue
  clueState.PRE_CLUE_WHITESPACE = 6 -- this state allows for 1 hyphen
  clueState.CLUE = 7 -- the clue allows 1 hyphen
  clueState.CLUE_ON_HYPHEN = 8
  clueState.POST_WHITESPACE = 9

  local clue = ""
  local number = ""

  local invalid = false
  local state = clueState.PRE_WHITESPACE
  local hyphenCount = 0
  -- process clue backwards as it is easier
  for ind = #processedClue, 1, -1 do
    -- This state machine will detect an invalid clue and stop processing if it
    -- finds an invalid character before it reaches the beginning of the input
    local ch = string.sub(processedClue,ind,ind)
    local code = string.unicode(ch)
    if state == clueState.PRE_WHITESPACE then
      if string.lower(ch) == "f" then
        state = clueState.INF_N
        number = "inf"
      elseif digitCharacters[code] then
        state = clueState.NUMBER
        number = digitCharacters[code]..number
      elseif whitespaceCharacters[code] then
        -- continue
      else
        invalid = true
      end
    elseif state == clueState.INF_N then
      if string.lower(ch) == "n" then
        state = clueState.INF_I
      else
        invalid = true
      end
    elseif state == clueState.INF_I then
      if string.lower(ch) == "i" then
        state = clueState.INF_WHITESPACE
      else
        invalid = true
      end
    elseif state == clueState.NUMBER then
      if digitCharacters[code] then
        number = digitCharacters[code]..number
      elseif whitespaceCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
        hyphenCount = hyphenCount + 1
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        hyphenCount = 0
        clue = ch..clue
      end
    elseif state == clueState.INF_WHITESPACE then
      if whitespaceCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.PRE_CLUE_WHITESPACE
        hyphenCount = hyphenCount + 1
      else
        invalid = true
      end
    elseif state == clueState.PRE_CLUE_WHITESPACE then
      if whitespaceCharacters[code] then
        -- continue
      elseif hyphenCharacters[code] and hyphenCount < 1 then
        hyphenCount = hyphenCount + 1
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        hyphenCount = 0
        clue = ch..clue
      end
    elseif state == clueState.CLUE or state == clueState.CLUE_ON_HYPHEN then
      if whitespaceCharacters[code] then
        if state == clueState.CLUE_ON_HYPHEN then
          invalid = true
        end
        state = clueState.POST_WHITESPACE
      elseif hyphenCharacters[code] then
        state = clueState.CLUE_ON_HYPHEN
        hyphenCount = hyphenCount + 1
        if hyphenCount > 1 then
          invalid = true
        end
        clue = ch..clue
      elseif illegalCharacters[code] then
        invalid = true
      else
        state = clueState.CLUE
        clue = ch..clue
      end
    elseif state == clueState.POST_WHITESPACE then
      if whitespaceCharacters[code] then
        -- continue
      else
        invalid = true
      end
    else
      invalid = true -- we should never reach here
    end

    if invalid then
      -- This is an invalid clue
      -- print("c:", clue, " n:", number, " i:", ind, " ch:", ch, " code:", code, " state:", state)
      return nil, nil, true
    end
  end

  if not (state == clueState.CLUE or state == clueState.POST_WHITESPACE) or clue == "" then
    -- We either ended on a hyphen or did not receive a parsable clue
    return nil, nil, true
  end

  -- Clean number value
  if number != "inf" then
    number = tostring(tonumber(number))
  end

  -- Return the clue and number
  return clue, number, false
end

function encodeClue(color, clue)
  local finishedClue
  local cluePosition
  local token = color == "Red" and redToken or blueToken
  local broadcastTo = color == "Red" and {"Orange", "Yellow", "Pink", "Brown"} or {"Teal", "Purple", "Green", "White"}

  local clues = color == "Red" and gameState.redClues or gameState.blueClues
  local xPos = color == "Red" and -21.05 or 21.05
  local deletedClues = false
  local validClues = {}

  -- Check for deleted clues and shift the remaining if need be
  if #clues > 0 then
    -- Check for deleted clues
    for _,clue in ipairs(color == "Red" and gameState.redClues or gameState.blueClues) do
      if getObjectFromGUID(clue) ~= nil then
        table.insert(validClues, clue)
      else
        deletedClues = true
      end
    end
  end

  if deletedClues then
    if color == "Red" then
      gameState.redClues = validClues
    else
      gameState.blueClues = validClues
    end
    for i, clue in ipairs(validClues) do
      local clueObject = getObjectFromGUID(clue)
      clueObject.setPosition({xPos, 1.5, (12 - (((i - 1) % 8) * 2.05))})
      clueObject.setRotation({0, 180, 0})
    end
  end
  local finishedClue = token.clone({
    position     = token.getPosition(),
    snap_to_grid = true,
    callback_function = function(clue) table.insert(color == "Red" and gameState.redClues or gameState.blueClues, clue.guid) end
  })
  finishedClue.createButton({
      label=clue, function_owner=finishedClue, click_function="clue",
      position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}
  })
  finishedClue.setPosition({xPos, 1.5, (12 - ((#(color == "Red" and gameState.redClues or gameState.blueClues) % 8) * 2.05))})
  finishedClue.setRotation({0, 180, 0})
  finishedClue.setLock(false)
  finishedClue.drag_selectable = false
  finishedClue.setLuaScript(
    "function onload()\n"
      .. "self.createButton({\n"
        .. "label='" .. clue .. "', click_function='nullFunction', function_owner=self,\n"
        .. "position={0,0.2,0}, height=0, width=0, font_size=500, rotation={0,0,0}, scale={2, 2, 4/3}, font_color={1,1,1}\n"
      .. "})\n"
    .. "end\n"
  )
  printToAll("[a020f0]» " .. (color == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's clue is: " .. (color == "Red" and "[da1918]" or "[1f87ff]") .. clue .. " [a020f0]«")
  for _, playerColor in ipairs(broadcastTo) do
    Player[playerColor].broadcast("[a020f0]» [ffffff]Your clue is: " .. (color == "Red" and "[da1918]" or "[1f87ff]") .. clue .. " [a020f0]«")
  end
end

function isCodenamesCard(obj)
  if obj.type == "Card" then
    vals = obj.getCustomObject()
    if vals.face != nil and string.find(vals.face,"codenames")then
      return true
    end
  end
  return false
end

function isCodenamesClue(obj)
  if obj.type == "Board" then
    butts = obj.getButtons()
    if butts != nil and (#butts == 1 and butts[1].click_function == "nullFunction" or #butts == 2 and butts[1].click_function == "clue") and butts[1].scale == Vector(2, 2, 1.3333) and butts[1].position == Vector(0,0.2,0) then
      return true
    end
  end
  return false
end

function onObjectEnterContainer(container, object)
  -- if the displaced object is a codenames card then delete the container and refresh the cards
  if isCodenamesCard(object) then
    -- Check whether container is being destroyed so we only do this once for multiple deposited objects
    if not container.isDestroyed() then
      container.destruct()
      dealCardsDelayed()
    end
  end
end

function onPlayerConnect(player)
  -- Send analytics disclaimer
  player.print(chatDisclaimer, {1, 1, 1})

  -- Keep track of newly joined players that haven't had the global xml reloaded
  local id = player.steam_id
  if id then
    isPlayerNewlyJoined[id] = true
  end

  -- Check the blacklist for the player
  WebRequest.get(analytics.url .. "/games/player/blacklisted/" .. player.steam_id, function(responseRaw)
    if responseRaw.is_done and not responseRaw.is_error and responseRaw.text != "" then
      local response = JSON.decode(responseRaw.text)

      if response.record and response.record.dateAdded ~= nil then
        if settings.automod.autokick then
          player.kick()
        end
        printToAll("\n", {1, 1, 1})
        printToAll(player.steam_name .. " was found in the global Codenames blacklist!", redColor)
        printToAll("SteamID     : " .. player.steam_id, redColor)
        printToAll("Date Added  : " .. response.record.dateAdded, redColor)
        printToAll("Reason      : " .. response.record.reason, redColor)
        printToAll("\n", {1, 1, 1})
      end
    end
  end)
end

function onPlayerDisconnect(player)
  afk.personInfo[player.steam_id] = nil

  -- End session with player if one exists
  if gameState.status == 1 then
    if analytics.sessions[player.steam_id] ~= nil then
      api_playerSessionEnd(analytics.sessions[player.steam_id])
    end
  end
end

function onPlayerChangeColor(color)
  -- Change the player's view
  if color != "Grey" then
    Player[color].lookAt({
      position = {0, 0, 0},
      pitch    = 60,
      yaw      = 0,
      distance = 45
    })
  end

  -- Reset the global xml if the player hasn't had it reloaded while they were in the room
  if (color == "Red" or color == "Blue") then
    local id = Player[color].steam_id
    if id and isPlayerNewlyJoined[id] then
      UI.setXml(globalXmlText)
      Wait.frames(function()
            UI.setAttributes("redClueText", {text = currentEnteredClue["Red"] or "", placeholder   = "Enter clue here"})
            UI.setAttributes("blueClueText", {text = currentEnteredClue["Blue"] or "", placeholder   = "Enter clue here"})
          end,
          2)
      for _, p in pairs(Player.getPlayers()) do
        isPlayerNewlyJoined[p.steam_id] = nil
      end
    end
  end

  -- Reset the player's vote (if necessary)
  if gameState.status == 1 then
    local cardsToUpdate = {}
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
      if Player[playerColor].steam_id == nil and #voteData ~= 0 then
        for _, card in pairs(voteData) do
          cardsToUpdate[card] = true
        end
        votes[gameState.turnTracker][playerColor] = {}
      end
    end
    for card, _ in pairs(cardsToUpdate) do
      updateVoteUI(card)
    end
  end

  local endSession = {}

  -- Resolve team changes, if necessary
  if color == "Red" or color == "Blue" then
    Player[color].team = "Hearts"
  elseif color == "Grey" then
    local spectators = Player.getSpectators()
    for _,spec in ipairs(spectators) do
      if analytics.sessions[spec.steam_id] ~= nil then
        table.insert(endSession, analytics.sessions[spec.steam_id])
      end
      if spec.team != "None" then
        spec.team = "None"
      end
    end
  else
    if Player[color].team != "None" then
      Player[color].team = "None"
    end
  end

  if color ~= "Grey" and color ~= "Black" then
    if gameState.status == 1 and analytics.sessions[Player[color].steam_id] == nil then
      api_playerSessionStart(Player[color].steam_id)
    end
  elseif gameState.status == 1 and (color == "Grey" or color == "Black") and #endSession ~= 0 then
    for _, sessionID in ipairs(endSession) do
      api_playerSessionEnd(sessionID)
    end
  end
end

function startTime()
  if settings.timer.enabled then
    if gameState.firstTurn then
      tableObject.call("startTimer", settings.timer.initial * 60)
    else
      tableObject.call("startTimer", settings.timer.subsequent * 60)
    end
  end
end

-- Deck fetching
function setDeck(deckID)
  if deckID == nil then
    deck.selected = {}
    return
  end

  if not deck.multiple then
    deck.selected = { deckID }
  else
    local exists = 0
    for deckIndex, deckGUID in ipairs(deck.selected) do
      if deckGUID == deckID then
        exists = deckIndex
      end
    end

    if exists == 0 then
      -- Insert the deck into the selected list
      table.insert(deck.selected, deckID)
    else
      -- Remove the deck from the list
      table.remove(deck.selected, exists)
    end
  end
end

function downloadDecks()
  if deckHandler.fetchingDecks then
    return
  end
  for i = 1, 20, 1 do
    tableObject.UI.hide("deck" .. i)
  end
  api_getDecks()
  -- Display message when done fetching decks
  Wait.condition(
        function() broadcastToAll("[a020f0]» [ffffff]Deck list refreshed! [a020f0]«", redColor) end,
        function() return not deckHandler.fetchingDecks end,
        15,
        function() resetDeckHandler() deckHandler.entireDeckList = deck.currentDeckList refreshDeckElements() error("Deck refresh failed") end
  )
end

function clearAllVotes()
  local cardsToUpdate = {}
  for turnNum, team in pairs(votes) do
    for seatColor, voteData in pairs(team) do
      for _, v in pairs(voteData) do
        cardsToUpdate[v] = true
      end
      votes[turnNum][seatColor] = {}
    end
  end
  for card, _ in pairs(cardsToUpdate) do
    updateVoteUI(card)
  end
end

-- Restrict newGame permissions to Red/Blue/Promoted/Host
function startGame(player)
  -- Check to see whether a new game is currently being set up
  if gameState.status == 0 then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]A new game is already starting. Please wait. [a020f0]«")
    return
  end

  -- Check to see if a deck has been chosen
  if #deck.selected == 0 then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You must select a deck before starting. [a020f0]«")
    return
  end

  -- A new game is currently starting - block any other new game requests
  gameState.status = 0
  Wait.time(function() if gameState.status == 0 then gameState.status = 1 end end, 8, 1)

  -- Reset the game to its original state
  resetGame()

  if settings.playerShuffle then
    startLuaCoroutine(tableObject, "shufflePlayers")
  elseif settings.codemasterQueue then
    startLuaCoroutine(tableObject, "swapCodemasters")
  else
    api_gameStart()
  end
end

function resetGame()
  -- Reset card data
  for cardNum, cardData in ipairs(cards) do
    local cardObject = getObjectFromGUID(cardData.guid)
    if cardObject then
      cardObject.interactable = true
      cardObject.setLock(false)
    end

    cardData.id       = nil
    cardData.value    = nil
    cardData.color    = nil
    cardData.covered  = false
  end

  -- Reset the agent cards to their start positions
  for guid, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(guid)
    if agentObject then
      local isExtraCard = (agentObject.guid == extraBlue.guid) or (agentObject.guid == extraRed.guid)
      agentObject.interactable = not isExtraCard
      agentObject.setLock(isExtraCard)
      agentObject.setPositionSmooth(isExtraCard and {0, -2, -14} or agentData.position)
      agentObject.setRotationSmooth({0, 180, 180})
      agents[agentObject.guid].enabled = not isExtraCard
      agents[agentObject.guid].covering = nil
    end
  end

  -- Delete clue tiles
  for _, obj in pairs(getObjects()) do
    if isCodenamesClue(obj) then
      obj.destruct()
    end
  end

  -- Reset team votes
  clearAllVotes()

  -- Reset game state variables
  gameState.firstTurn   = true
  gameState.guessesLeft = -1
  gameState.canVote     = false
  gameState.redClues    = {}
  gameState.blueClues   = {}
end

function setupGame()
  -- Determine which team should go first (0 = RED; 1 = BLUE)
  gameState.turnTracker = math.random(2) - 1

  -- Shuffle the keymap
  local bank = {"Red", "Red", "Red", "Red", "Red", "Red", "Red", "Red", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "Blue", "White", "White", "White", "White", "White", "White", "White", "Black"}
  if gameState.turnTracker == 0 then
    -- Add another red
    bank = table.insert(bank, "Red")
  else
    -- Add another blue
    bank = table.insert(bank, "Blue")
  end

  local words = deck.words

  for i = 1, 25, 1 do
    local nextCard = table.remove(words, math.random(1, #words))
    cards[i].id     = nextCard.id
    cards[i].value  = nextCard.word:upper()
    cards[i].color  = table.remove(bank, math.random(1, #bank))
  end

  -- Choose the correct double agent card for which team goes first
  local extraCard = gameState.turnTracker == 0 and extraRed or extraBlue

  -- Set the correct double card to red
  extraCard.setLock(false)
  extraCard.setRotation({0, 180, 180})
  extraCard.setPositionSmooth(agents[extraCard.guid].position)
  extraCard.interactable = true
  agents[extraCard.guid].enabled = true

  -- Change the turn indicator
  local previousTurn = (gameState.turnTracker == 0 and "blue" or "red") .. "Turn"
  local currentTurn = (gameState.turnTracker == 0 and "red" or "blue") .. "Turn"
  local teamColorTurn = gameState.turnTracker == 0 and "Red" or "Blue"
  tableObject.UI.setAttribute(previousTurn, "active", false)
  tableObject.UI.setAttribute(currentTurn, "active", true)
  tableObject.UI.setAttribute(previousTurn .. "BG", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "BG", "active", true)
  tableObject.UI.setAttribute(previousTurn .. "Square", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "Square", "active", true)
  tableObject.UI.setAttribute("timer", "outline", teamColorTurn)
  printToAll("[a020f0]» " .. (teamColorTurn == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's turn! [a020f0]«")

  dealCards()

  -- Start the timer
  gameState.firstTurn = true
end

function dealCardsDelayed()
  if dealCards_WaitId != nil then
    Wait.stop(dealCards_WaitId)
    dealCards_WaitId = nil
  end
  dealCards_WaitId = Wait.time(dealCards,2.5,1)
end

-- Deals the cards on the board
function dealCards()
  -- check all objects to delete unused codenames cards
  for _, obj in pairs(getObjects()) do
    if isCodenamesCard(obj) and not isCard(obj.guid) then
      obj.destruct()
    end
  end
  for i = 1, 25, 1 do
    local cardObject = getObjectFromGUID(cards[i].guid)
    if cards[i].guid == nil or cardObject == nil then
      -- Get new card if it doesn't exist
      local c = cardTemplates.takeObject({
        position            = {cards[i].position.x, 1.03, cards[i].position.z},
        rotation            = {0, 180, 0},
        snap_to_grid        = true,
        callback_function   = function(card) setCardData(card, i) end
      })
    else
      -- Set the UI
      setCardData(cardObject, i)
    end
  end
end

function setCardData(card, i)
  cards[i].guid = card.guid

  card.call("setData", {
    position  = cards[i].position,
    text      = cards[i].value,
    color     = cards[i].color
  })

  card.setLock(false)
  card.drag_selectable = false

  card.setName(cards[i].value)

  -- Once the last card has loaded in, allow a new game to be started
  if i == 25 and gameState.status == 0 then
    startTime()
    gameState.status = 1
  end
end

function findClosestCard(threshold, position)
  local closestCard =
  {
    index = nil,
    distance = nil
  }

  for cardIndex,_ in ipairs(cards) do
    local dX = position.x - cards[cardIndex].position.x
    local dZ = position.z - cards[cardIndex].position.z

    local d = math.sqrt((dX^2) + (dZ^2))

    if d < threshold then
      if closestCard.index == nil or d < closestCard.distance then
        closestCard.index = cardIndex
        closestCard.distance = d
      end
    end
  end

  return closestCard.index
end

function onObjectDrop(color, agent)
  -- Ensure that the dropped object is an agent card
  if gameState.status ~= 1 or agent.type ~= "Tile" or agents[agent.guid] == nil then
    return
  end

  -- Find the closest card position to the dropped agent
  local cardIndex = findClosestCard(1.65, agent.getPosition())
  if cardIndex == nil or cards[cardIndex].covered then
    -- Either no close card found, or card is already covered
    agent.setAngularVelocity({0, 0, 0})
    agent.setVelocity({0, 0, 0})
    agent.setRotation({0, 180, 180})
    agent.setPositionSmooth(agents[agent.guid].position)
    return
  end

  -- Check to see if the agent and the card are the same color
  local agentColor = agents[agent.guid].color
  local cardColor = cards[cardIndex].color
  if cardColor ~= agentColor then
    agent.setAngularVelocity({0, 0, 0})
    agent.setVelocity({0, 0, 0})
    agent.setRotation({0, 180, 180})
    agent.setPositionSmooth(agents[agent.guid].position)
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]An agent has been placed incorrectly. You placed a " .. agentColor .. " agent on a " .. cardColor .. " card. [a020f0]«")
    return
  end

  -- Card has been marked correctly
  gameState.guessesLeft = gameState.guessesLeft - 1
  cards[cardIndex].covered = true

  coverCard(cardIndex, agent.guid)

  -- Remove votes on the card
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    local ind = findInArray(cardIndex,voteData)
    if ind != nil then
      table.remove(votes[gameState.turnTracker][playerColor],ind)
    end
  end
  updateVoteUI(cardIndex)

  -- Send analytics data for the guess
  local players = ""
  local correct = ((gameState.turnTracker == 0 and cardColor == "Red") or (gameState.turnTracker == 1 and cardColor == "Blue")) and "TRUE" or "FALSE"
  for color,_ in pairs(votes[gameState.turnTracker]) do
    if Player[color].steam_id != nil then
      players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
    end
  end
  api_clueGuess(players, cards[cardIndex].id, correct, cardColor:upper())

  local messageColor = {
    ["Red"] = "da1918",
    ["Blue"] = "1f87ff",
    ["White"] = "ffffff",
    ["Black"] = "191919"
  }

  if correct == "TRUE" then
    -- Play the correct sound effect
    tableObject.AssetBundle.playTriggerEffect(0)
    printToAll("[a020f0]» [31b32b][✓] [" .. messageColor[cardColor] .. "]" .. cardColor:upper() .. " [ffffff]team has correctly guessed: [" .. messageColor[cardColor]  .."]" .. cards[cardIndex].value:upper() .. " [a020f0]«")
  else
    -- Play the wrong sound effect
    tableObject.AssetBundle.playTriggerEffect(1)
    local guessingTeam = gameState.turnTracker == 0 and "Red" or "Blue"
    printToAll("[a020f0]» [da1918][✗] [" .. messageColor[guessingTeam] .. "]" .. guessingTeam:upper() .. " [ffffff]team has incorrectly guessed: [" .. messageColor[cardColor]  .."]" .. cards[cardIndex].value:upper() .. " [a020f0]«")
  end

  -- Check to see if either red or blue won
  local redWon = true
  local blueWon = true
  for i = 1, 25, 1 do
    if cards[i].color == "Red" and not cards[i].covered then
      redWon = false
    elseif cards[i].color == "Blue" and not cards[i].covered then
      blueWon = false
    end

    if not redWon and not blueWon then
      -- Skip unnecessary iterations
      break
    end
  end

  if agentColor == "Black" or blueWon or redWon then
    -- End game scenario

    -- Analytics data for end of game
    if (agentColor == "Black" and gameState.turnTracker == 0) or blueWon then
      -- Red placed black card, blue wins
      -- or blue placed all of their cards
      broadcastToAll("[a020f0]» [1f87ff]BLUE [ffffff]team wins! [a020f0]«")
      api_gameEnd("BLUE")
    elseif (agentColor == "Black" and gameState.turnTracker == 1) or redWon then
      -- Blue placed black card, red wins
      -- or red placed all of their cards
      broadcastToAll("[a020f0]» [da1918]RED [ffffff]team wins! [a020f0]«")
      api_gameEnd("RED")
    end

    -- Move the remaining agents to their codes
    endGame()
  elseif gameState.guessesLeft == 0 or agentColor == "White" or (agentColor == "Red" and gameState.turnTracker == 1) or (agentColor == "Blue" and gameState.turnTracker == 0) then
    toggleTurns()
  else
    -- Show the pass turn button and change color
    tableObject.UI.setAttributes("passTurn", {
      color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
      active = true
    })
  end
end

function playerVote(color, card)
  -- Update the player's vote
  if color == "Grey" then
    -- Ignore votes from spectators
    return
  end

  if color == "Red" or color == "Blue" or color == "Black" then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You cannot vote! [a020f0]«")
    return
  elseif votes[gameState.turnTracker][color] == nil then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to vote! [a020f0]«")
    return
  elseif not gameState.canVote then
    Player[color].broadcast("[a020f0]» [da1918]ERROR: [ffffff]You can't vote until you've been given a clue! [a020f0]«")
    return
  end

  local ind = findInArray(card,votes[gameState.turnTracker][color])
  if not settings.multivoting then
    -- Remove all of player's other votes
    local cardsToUpdate = {}
    for _, card in pairs(votes[gameState.turnTracker][color]) do
      cardsToUpdate[card] = true
    end
    votes[gameState.turnTracker][color] = {}
    for card, _ in pairs(cardsToUpdate) do
      updateVoteUI(card)
    end
  end
  if ind != nil then
    if settings.multivoting then
      -- Remove this player's vote
      table.remove(votes[gameState.turnTracker][color],ind)
      updateVoteUI(card)
    end
  else
    -- Add the player's vote
    table.insert(votes[gameState.turnTracker][color],card)
    updateVoteUI(card)

    -- Check to see if the card now has a passing vote
    local votePassed = false
    for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if Player[playerColor].seated and not Player[playerColor].blindfolded then
        votePassed = findInArray(card,voteData) != nil
        if votePassed == false then
          break
        end
      end
    end

    if votePassed then

      -- Vote passed to pass turn
      if card == 26 then
        toggleTurns()
        return
      end

      -- Card has been marked correctly
      gameState.guessesLeft = gameState.guessesLeft - 1
      cards[card].covered = true

      -- Cover the card
      coverCard(card, nil)

      -- Remove votes on the card
      for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
        local ind = findInArray(card,voteData)
        if ind != nil then
          table.remove(votes[gameState.turnTracker][playerColor],ind)
        end
      end
      updateVoteUI(card)

      -- Send analytics data for the guess
      local players = ""
      local correct = ((gameState.turnTracker == 0 and cards[card].color == "Red") or (gameState.turnTracker == 1 and cards[card].color == "Blue")) and "TRUE" or "FALSE"
      for color,_ in pairs(votes[gameState.turnTracker]) do
        if Player[color].seated then
          players = players .. ((players == "") and Player[color].steam_id or (',' .. Player[color].steam_id))
        end
      end
      api_clueGuess(players, cards[card].id, correct, cards[card].color:upper())

      local messageColor = {
        ["Red"] = "da1918",
        ["Blue"] = "1f87ff",
        ["White"] = "ffffff",
        ["Black"] = "191919"
      }
      if correct == "TRUE" then
        -- Play the correct sound effect
        tableObject.AssetBundle.playTriggerEffect(0)
        printToAll("[a020f0]» [31b32b][✓] [" .. messageColor[cards[card].color] .. "]" .. cards[card].color:upper() .. " [ffffff]team has correctly guessed: [" .. messageColor[cards[card].color]  .."]" .. cards[card].value:upper() .. " [a020f0]«")
      else
        -- Play the wrong sound effect
        tableObject.AssetBundle.playTriggerEffect(1)
        local guessingTeam = gameState.turnTracker == 0 and "Red" or "Blue"
        printToAll("[a020f0]» [da1918][✗] [" .. messageColor[guessingTeam] .. "]" .. guessingTeam:upper() .. " [ffffff]team has incorrectly guessed: [" .. messageColor[cards[card].color]  .."]" .. cards[card].value:upper() .. " [a020f0]«")
      end

      -- Check to see if either red or blue won
      local redWon = true
      local blueWon = true
      for i = 1, 25, 1 do
        if cards[i].color == "Red" and not cards[i].covered then
          redWon = false
        elseif cards[i].color == "Blue" and not cards[i].covered then
          blueWon = false
        end

        if not redWon and not blueWon then
          -- Skip unnecessary iterations
          break
        end
      end

      if cards[card].color == "Black" or blueWon or redWon then
        -- End game scenario

        if (cards[card].color == "Black" and gameState.turnTracker == 0) or blueWon then
          -- Red placed black card, blue wins
          -- or blue placed all of their cards
          broadcastToAll("[a020f0]» [1f87ff]BLUE [ffffff]team wins! [a020f0]«")
          api_gameEnd("BLUE")
        elseif (cards[card].color == "Black" and gameState.turnTracker == 1) or redWon then
          -- Blue placed black card, red wins
          -- or red placed all of their cards
          broadcastToAll("[a020f0]» [da1918]RED [ffffff]team wins! [a020f0]«")
          api_gameEnd("RED")
        end

        -- Move the remaining agents to their codes
        endGame()

      elseif gameState.guessesLeft == 0 or cards[card].color == "White" or (cards[card].color == "Red" and gameState.turnTracker == 1) or (cards[card].color == "Blue" and gameState.turnTracker == 0) then
        toggleTurns()
        local cardsToClear = {}
        for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
          for _, card in pairs(voteData) do
            cardsToClear[card] = true
          end
          votes[gameState.turnTracker][playerColor] = {}
        end
        for card, _ in pairs(cardsToClear) do
          updateVoteUI(card)
        end
      else
        -- Show the pass turn button and change color
        tableObject.UI.setAttributes("passTurn", {
          color = gameState.turnTracker == 0 and "#da1918" or "#1f87ff",
          active = true
        })
      end
    end
  end
end

function coverCard(cardIndex, agentGUID)
  local cardObject = getObjectFromGUID(cards[cardIndex].guid)
  for guid, agentData in pairs(agents) do
    local agentObject = getObjectFromGUID(guid)
    if agents[guid].enabled and agentData.color == cards[cardIndex].color and agentObject and agentObject.interactable and (agentGUID == nil or agentGUID == guid) then
      local position = {cards[cardIndex].position.x, 1.03, cards[cardIndex].position.z}

      -- Track the index of the card this agent is covering
      agents[guid].covering = cardIndex

      -- Lock both cards and set them in place
      cardObject.interactable = false
      agentObject.interactable = false

      cardObject.setLock(true)
      agentObject.setLock(true)

      -- Ensure the tile is on the code
      cardObject.setRotationSmooth({0, 180, 0})
      agentObject.setRotationSmooth({0, 180, 180})

      cardObject.setPositionSmooth(position)
      agentObject.setPositionSmooth(position)

      break
    end
  end
end

function updateVoteUI(card)
  local uiObject = card == 26 and tableObject or getObjectFromGUID(cards[card].guid)
  if uiObject == nil then
    return
  end

  local votesToAdd = {}
  for playerColor, voteData in pairs(votes[gameState.turnTracker]) do
    if findInArray(card,voteData) != nil then
      votesToAdd[playerColor] = true
    end
  end
  local votesOnCard =
  {
    uiObject.UI.getAttribute("vote-1", "color"),
    uiObject.UI.getAttribute("vote-2", "color"),
    uiObject.UI.getAttribute("vote-3", "color"),
    uiObject.UI.getAttribute("vote-4", "color")
  }
  local newVotes = {}

  -- Keep the order of the current votes
  for voteIndex, voteColor in ipairs(votesOnCard) do
    if voteColor ~= "Black" then
      if findInArray(card,votes[gameState.turnTracker][voteColor]) != nil then
        table.insert(newVotes, voteColor)
        votesToAdd[voteColor] = nil
      end
    else
      -- Add the uncounted votes
      for playerColor,_ in pairs(votesToAdd) do
        table.insert(newVotes, playerColor)
      end
      break
    end
  end

  for i = 1,4,1 do
    if newVotes[i] ~= nil then
      uiObject.UI.setAttributes("vote-" .. i, {
        color = newVotes[i],
        active = true
      })
    else
      uiObject.UI.setAttributes("vote-" .. i, {
        color = "Black",
        active = false
      })
    end
  end
end

function votePass(color)
  playerVote(color, 26)
end

function onPlayerAction(player, action, objects)
  local processAction     = false
  local actionsToProcess  = {
    Player.Action.PickUp,
    Player.Action.RotateIncrementalLeft,
    Player.Action.RotateIncrementalRight,
    Player.Action.RotateOver,
    Player.Action.FlipIncrementalLeft,
    Player.Action.FlipIncrementalRight,
    Player.Action.FlipOver,
    Player.Action.Delete
  }

  for _, handledAction in ipairs(actionsToProcess) do
    if action == handledAction then
      processAction = true
      break
    end
  end

  if not processAction then
    return
  end

  if action == Player.Action.Delete then
    -- if there is an ongoing game and a card is deleted then refresh the cards
    for _, obj in pairs(objects) do
      if gameState.status == 1 and isCodenamesCard(obj) then
        -- Delete word cards and refresh them
        dealCardsDelayed()
        obj.destruct()
      elseif agents[obj.guid] ~= nil then
        -- Do not delete any agents
      else
        -- Delete any other objects in the action
        obj.destruct()
      end
    end
    -- Prevent deletion of selected objects as we have already delete only what was allowed
    return false
  end

  local objectIncludesCard = false
  local objectIncludesAgent = false

  -- See if there is a card included in the table of objects
  for _, object in ipairs(objects) do
    if isCard(object.guid) then
      objectIncludesCard = true
    elseif agents[object.guid] ~= nil then
      objectIncludesAgent = true
    end
  end

  if objectIncludesCard and (player.color == "Blue" or player.color == "Red" or player.color == "Black") then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You're not allowed to do that! [a020f0]«")
    return false
  end

  -- Disable interacting with agents if player isn't a codemaster
  if objectIncludesAgent and player.color ~= "Blue" and player.color ~= "Red" then
    player.broadcast("[a020f0]» [da1918]ERROR: [ffffff]You're not allowed to do that! [a020f0]«")
    return false
  end

  local isPlayerTurn = (votes[gameState.turnTracker][player.color] ~= nil)
  local errorMessage

  if action == Player.Action.PickUp then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]It's not your turn to vote! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't vote until you've been given a clue! [a020f0]«"
    end
    if #objects == 1 and objects[1].type == "Card" and not objects[1].spawning then
      object = objects[1]
      for i = 1, 25, 1 do
        if cards[i].guid == object.guid then
          if #player.getSelectedObjects() <= 1 then
            playerVote(player.color, i)
          end
          return false
        end
      end
    end
    local hasCards = false
    for _, obj in pairs(objects) do
      if isCard(obj.guid) then
        obj.removeFromPlayerSelection(player.color)
        hasCards = true
      end
    end
    if hasCards then
      return false
    end
  elseif action == Player.Action.RotateIncrementalLeft or action == Player.Action.RotateIncrementalRight or action == Player.Action.RotateOver then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't tilt cards when it's not your turn! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't tilt cards until you've been given a clue! [a020f0]«"
    end
  elseif action == Player.Action.FlipIncrementalLeft or action == Player.Action.FlipIncrementalRight or action == Player.Action.FlipOver then
    if objectIncludesCard and not isPlayerTurn then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't flip cards when it's not your turn! [a020f0]«"
    elseif settings.cardTilting and gameState.status == 1 and not gameState.canVote then
      errorMessage = "[a020f0]» [da1918]ERROR: [ffffff]You can't flip cards until you've been given a clue! [a020f0]«"
    end
  end

  if errorMessage ~= nil then
    player.broadcast(errorMessage, redColor)
    return false
  end
end

function isCard(guid)
  for _, cardData in ipairs(cards) do
    if guid == cardData.guid then
      return true
    end
  end
  return false
end

function endGame()
  clearAllVotes()

  -- Disable voting for any teams
  gameState.canVote = false

  -- Set the game back to initial state
  gameState.status = -1

  -- Stop the timer
  tableObject.call("stopTimer", true)

  -- Hide the pass turn button and change color
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Assign remaining agents to uncovered clues
  for i = 1, 25, 1 do
    if not cards[i].covered then
      coverCard(i, nil)
    end
  end
end

function timeExpired()
  -- Play the timer expired sound
  tableObject.AssetBundle.playTriggerEffect(2)

  toggleTurns()
end

-- Command implementations
function onChat(message, player)
  if not player.admin then
    return
  end

  local command, color = processChat(message)
  local ranCommand = false

  if command == nil then
    return
  end

  if command == "!kick" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if Player[color].steam_id == nil then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has kicked " .. Player[color].steam_name .. ".", redColor)
    Player[color].kick()
    ranCommand = true
  elseif command == "!blind" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if Player[color].steam_id == nil then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has " .. (not Player[color].blindfolded and "blindfolded " or "unblindfolded ") .. Player[color].steam_name .. ".", redColor)
    Player[color].blindfolded = not Player[color].blindfolded
    ranCommand = true
  elseif command == "!stand" then
    if not isColor(color) then
      player.broadcast("Invalid color!", redColor)
      return false
    end

    if not Player[color].seated then
      player.broadcast("There's no player seated in " .. color:lower() .. "!", redColor)
      return false
    end
    printToAll(player.steam_name .. " has stood " .. Player[color].steam_name .. ".", redColor)
    Player[color].changeColor("Grey")
    ranCommand = true
  end

  if ranCommand then
    return false
  end
end

function isColor(userColor)
  for _, color in ipairs(Player.getColors()) do
    if color ~= "Grey" and color:lower() == userColor:lower() then
      return true
    end
  end
  return false
end

function processChat(message)
  local raw = string.gmatch(message, "%S+")
  local firstWord = true
  local command = nil
  local args = ""
  for word in raw do
    if firstWord then
      if word:sub(1, 1) ~= "!" then
        return command, args
      else
        command = word
        firstWord = false
      end
    else
      args = args .. word .. " "
    end
  end

  return command, args:gsub("^%s*(.*%S+)%s*$", "%1"):gsub("^%s+$","")
end

function toggleTurns()
  -- Diable voting for the current team
  gameState.canVote = false

  clearAllVotes()

  -- Disable card tilting
  for _, card in ipairs(cards) do
    if not card.covered then
      local cardObject = getObjectFromGUID(card.guid)
      if settings.cardTilting then
        cardObject.setLock(true)
      end
      cardObject.setRotationSmooth({0, 180, 0})
    end
  end

  -- Hide the pass turn button
  tableObject.UI.setAttributes("passTurn", {
    color = "#aaaaaa",
    active = false
  })

  -- Reset the timer warning
  timerWarning = -1

  -- Make sure it isn't the first turn
  gameState.firstTurn = false

  -- Reset the guesses each team has left
  gameState.guessesLeft = -1

  -- Reset the clueID
  analytics.clueID = nil

  -- Play the button press effect
  local button = (gameState.turnTracker == 0 and buttonRed or buttonBlue)
  button.AssetBundle.playTriggerEffect(0)

  -- Change the tracker to the other team's turn
  gameState.turnTracker = (gameState.turnTracker == 0 and 1 or 0)

  -- Change the location of the turn marker
  local previousTurn = (gameState.turnTracker == 0 and "blue" or "red") .. "Turn"
  local currentTurn = (gameState.turnTracker == 0 and "red" or "blue") .. "Turn"
  local teamColorTurn = gameState.turnTracker == 0 and "Red" or "Blue"
  tableObject.UI.setAttribute(previousTurn, "active", false)
  tableObject.UI.setAttribute(currentTurn, "active", true)
  tableObject.UI.setAttribute(previousTurn .. "BG", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "BG", "active", true)
  tableObject.UI.setAttribute(previousTurn .. "Square", "active", false)
  tableObject.UI.setAttribute(currentTurn .. "Square", "active", true)
  tableObject.UI.setAttribute("timer", "outline", teamColorTurn)
  printToAll("[a020f0]» " .. (teamColorTurn == "Red" and "[da1918]RED" or "[1f87ff]BLUE") .. " [ffffff]team's turn! [a020f0]«")

  startTime()
end

function endTurn(button, color)
  if color == "Red" or color == "Blue" then
    -- Is it the current side's turn?
    if gameState.turnTracker == 0 and button.guid == buttonBlue.guid or gameState.turnTracker == 1 and button.guid == buttonRed.guid then
      return
    end

    toggleTurns()

  end
end

-------------------------------------------------------------------------------
--------------------------------[[ ANALYTICS ]]--------------------------------
-------------------------------------------------------------------------------

function apiGet(api, callback)
  WebRequest.get(analytics.url .. api, callback)
end

function apiPost(api, payload, callback)
  WebRequest.post(analytics.url .. api, payload, callback)
end

function getJSON(responseRaw)
  if not responseRaw.is_done or responseRaw.is_error or responseRaw.text == "" then
    return nil
  end

  local response = JSON.decode(responseRaw.text)

  if response.status == "error" then
    print("API Error: " .. response.message)
    return nil
  end

  return response
end

-------------- /games/decks --------------
function api_getDecks()
  deckHandler.fetchingDecks = true


  -- If fetching decks doesn't complete after 15 seconds, then dislay an error
  Wait.condition(function() end, function() return not deckHandler.fetchingDecks end, 15, function() error("Error getting decks.") end)

  -- Request a single deck just to see how many decks there are to request
  apiGet("/games/decks?pageSize=1&pageNum=0", api_getDecksCB)
end

function api_getDecksCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  deckHandler.totalDecks = tonumber(response["decks"]["totalDecks"])

  -- Update the internal list of decks
  if deckHandler.totalDecks == nil then
    print("Error getting decks2.")
    resetDeckHandler()
    deckHandler.entireDeckList = deck.currentDeckList
  else
    deckHandler.totalPages = math.ceil(deckHandler.totalDecks / deckHandler.DECK_REQUEST_COUNT)
    if deckHandler.totalDecks == 0 then
      resetDeckHandler()
      deckHandler.entireDeckList = deck.currentDeckList
    else
      -- Request all the decks from the server in small chunks so JSON.decode doesn't lag the game. Starting with page 0
      apiGet("/games/decks?pageSize=" .. deckHandler.DECK_REQUEST_COUNT .. "&pageNum=" .. 0, api_getDeckSubsetCB)
    end
  end
end

function api_getDeckSubsetCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Get the page number for this request from the URL
  local pageNum = ""
  for i = #responseRaw.url, 1, -1 do
    local ch = string.sub(responseRaw.url, i, i)
    if string.find("1234567890", ch, 1, true) != nil then
      pageNum = ch .. pageNum
    else
      break
    end
  end

  if tonumber(pageNum) == nil then
    print("Error: The url has no page number " .. responseRaw.url)
    return
  else
    pageNum = tonumber(pageNum) + 1
  end

  -- Add the decks to entireDeckList at the appropriate index
  local deckList = response["decks"]["deckList"]

  local pageStart = (pageNum - 1) * deckHandler.DECK_REQUEST_COUNT
  for i, deck in pairs(deckList) do
    deckHandler.entireDeckList[pageStart + i] = deck
  end

  -- Check if we have already processed this page
  if deckHandler.acquiredPages[pageNum] then
    print("Error: already processed page "..pageNum.." "..printTable(deckHandler.acquiredPages,true))
    return
  end
  deckHandler.acquiredPages[pageNum] = true

  if #deckHandler.acquiredPages == deckHandler.totalPages then
    -- Deck is complete! Populate it!
    if #deckHandler.entireDeckList != deckHandler.totalDecks then
      print("Error: not all decks populated.  Expected ",deckHandler.totalDecks," and got ",#deckHandler.entireDeckList)
    end

    local assets = UI.getCustomAssets()
    local asset_names = {}
    local isAssetsUpdated = false

    -- Create a lookup table for the steamids of the custom assets
    for _, entry in pairs(assets) do
      asset_names[entry.name] = true
    end

    deckList = deckHandler.entireDeckList
    for i = 1, #deckList do
      if deckList[i]["author"]["steamID"] and deckList[i]["author"]["profilePicture"] and not asset_names[deckList[i]["author"]["steamID"]] then
        isAssetsUpdated = true
        table.insert(assets, {
          name  = deckList[i]["author"]["steamID"],
          url   = deckList[i]["author"]["profilePicture"]:gsub(".jpg", "_full.jpg")
        })
      end
    end

    if isAssetsUpdated then
      UI.setCustomAssets(assets)
      -- Update once almost immediately to get the text in place. With 10 frames, the host will see the pictures
      Wait.frames(refreshDeckElements, 10)
      -- Update a second time after the images have had time to download for other players
      Wait.time(refreshDeckElements, 5, 1)
    else
      refreshDeckElements()
    end

    resetDeckHandler()
    deckHandler.entireDeckList = deckList
  else
    -- Request next page
    apiGet("/games/decks?pageSize=" .. deckHandler.DECK_REQUEST_COUNT .. "&pageNum=" .. pageNum, api_getDeckSubsetCB)
  end
end

-------------- /games/player/blacklisted/:steamID --------------
function api_getBlacklistInfo(steamID)
  apiGet("/games/player/blacklisted/" .. steamID, api_getBlacklistInfoCB)
end

function api_getBlacklistInfoCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  if response.dateAdded ~= nil then
    if settings.automod.autokick then
      --player.kick()
    end
    --[[
    printToAll("\n", {1, 1, 1})
    printToAll(player.steam_name .. " was found in the global Codenames blacklist!", redColor)
    printToAll("SteamID     : " .. player.steam_id, redColor)
    printToAll("Date Added  : " .. response.dateAdded, redColor)
    printToAll("Reason      : " .. response.reason, redColor)
    printToAll("\n", {1, 1, 1})]]
  end
end

-------------- /games/start --------------
function api_gameStart()
  local request =
  {
    host    = analytics.host,
    decks   = "",
    first   = gameState.turnTracker == 0 and "RED" or "BLUE",
    players = ""
  }

  for deckIndex, deck in ipairs(deck.selected) do
    if deckIndex == 1 then
      request.decks = request.decks .. deck
    else
      request.decks = request.decks .. "," .. deck
    end
  end

  for _, player in ipairs(Player.getPlayers()) do
    local color = player.color
    if color ~= "Grey" and color ~= "Black" then
      request.players = request.players .. ((request.players == "") and player.steam_id or (',' .. player.steam_id))
    end
  end

  apiPost("/games/start", request, api_gameStartCB)
end

function api_gameStartCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Set the current game ID
  analytics.gameID = response.gameID

  -- Reset player sessions
  analytics.sessions = {}
  for _, session in ipairs(response.sessions) do
    analytics.sessions[session.steamID] = session.sessionID
  end

  -- Set the words for the current deck
  deck.words = response.words

  -- Reset the previous clue ID
  analytics.clueID = nil

  -- Continue setup of the game
  setupGame()
end

-------------- /games/end --------------
function api_gameEnd(winner)
  local request =
  {
    gameID  = analytics.gameID,
    winner  = winner
  }

  apiPost("/games/end", request, api_gameEndCB)
end

function api_gameEndCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Set the current game ID
  analytics.gameID = nil

  -- Reset player sessions
  analytics.sessions = {}

  -- Reset the clue ID
  analytics.clueID = nil
end

-------------- /games/clues/new --------------
function api_newClue(clue, number, codemaster)
  local request =
  {
    gameID      = analytics.gameID,
    clue        = tostring(clue),
    number      = tostring(number),
    codemaster  = tostring(codemaster),
    team        = tostring(gameState.turnTracker == 0 and "RED" or "BLUE")
  }

  apiPost("/games/clues/new", request, api_newClueCB)
end

function api_newClueCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  analytics.clueID = response.clueID
end

-------------- /games/clues/guess --------------
function api_clueGuess(players, guess, correct, color)
  local request =
  {
    clueID  = analytics.clueID,
    players = players,
    guess   = guess,
    correct = correct,
    color   = color
  }

  apiPost("/games/clues/guess", request, api_clueGuessCB)
end

function api_clueGuessCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end
end

-------------- /games/players/sessions/start --------------
function api_playerSessionStart(player)
  local request =
  {
    gameID  = analytics.gameID,
    player  = player
  }

  apiPost("/games/players/sessions/start", request, api_playerSessionStartCB)
end

function api_playerSessionStartCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Record the session ID
  analytics.sessions[response.steamID] = response.sessionID
end

-------------- /games/players/sessions/end --------------
function api_playerSessionEnd(sessionID)
  local request =
  {
    sessionID = sessionID
  }

  apiPost("/games/players/sessions/end", request, api_playerSessionEndCB)
end

function api_playerSessionEndCB(responseRaw)
  local response = getJSON(responseRaw)
  if response == nil then
    return
  end

  -- Remove the session ID
  for steamID, sessionID in pairs(analytics.sessions) do
    if sessionID == response.sessionID then
      analytics.sessions[steamID] = nil
    end
  end
end

globalXmlText = [[<Panel id="redClues"
       visibility="Red"
       rectAlignment="LowerCenter"
       color="#da1918"
       height="100"
       width="650"
       outline="#ffffff"
       outlineSize="2 -2">

       <Panel rectAlignment="UpperRight" width="25" height="25">
         <Text id="codemasterHelp"
             fontStyle="Bold"
             fontSize="20"
             color="#ffffff"
             tooltip="Type in your clue and push ENTER once you're finished. Clues can&#xA;only be one word or contain one hyphen in them. You must include&#xA;a number (0, inf, 1-9) in your clue.&#xA;&#xA;Clues can be in any of the following formats:&#xA;* clue - 0&#xA;* clue inf&#xA;* clue1&#xA;* clue-clue 9&#xA;* etc">?
           </Text>
       </Panel>

       <InputField id="redClueText"
                   placeholder="Enter clue here"
                   alignment="MiddleCenter"
                   height="30"
                   width="550"
                   lineType="MultiLineNewLine"
                   onValueChanged="clueEntered">
       </InputField>

</Panel>

<Panel id="blueClues"
       visibility="Blue"
       rectAlignment="LowerCenter"
       color="#1f87ff"
       height="100"
       width="650"
       outline="#ffffff"
       outlineSize="2 -2">

       <Panel rectAlignment="UpperRight" width="25" height="25">
         <Text id="codemasterHelp"
             fontStyle="Bold"
             fontSize="20"
             color="#ffffff"
             tooltip="Type in your clue and push ENTER once you're finished. Clues can&#xA;only be one word or contain one hyphen in them. You must include&#xA;a number (0, inf, 1-9) in your clue.&#xA;&#xA;Clues can be in any of the following formats:&#xA;* clue - 0&#xA;* clue inf&#xA;* clue1&#xA;* clue-clue 9&#xA;* etc">?
           </Text>
       </Panel>

       <InputField id="blueClueText"
                   placeholder="Enter clue here"
                   alignment="MiddleCenter"
                   height="30"
                   width="550"
                   lineType="MultiLineNewLine"
                   onValueChanged="clueEntered">
       </InputField>

</Panel>]]
